name: Mirror images to Aliyun Registry

on:
  workflow_dispatch:
  push:
    branches: [ main ]

env:
  # 这些有值时会被脚本使用（均通过 GitHub Secrets 注入）
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"          # e.g. registry.cn-hangzhou.aliyuncs.com
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"      # 你的命名空间 / 仓库前缀
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
  # Docker Hub (可选) - 如果不设置，使用匿名拉取（可能受 rate limit）
  DOCKERHUB_USER: "${{ secrets.DOCKERHUB_USER }}"
  DOCKERHUB_PASSWORD: "${{ secrets.DOCKERHUB_PASSWORD }}"

jobs:
  mirror:
    name: Mirror images from images.txt -> Aliyun
    runs-on: ubuntu-latest
    timeout-minutes: 120
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install skopeo and jq
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y skopeo jq

      - name: Show environment (for debug)
        run: |
          echo "ALIYUN_REGISTRY=${ALIYUN_REGISTRY}"
          echo "ALIYUN_NAME_SPACE=${ALIYUN_NAME_SPACE}"
          # DO NOT echo secrets such as passwords

      - name: Mirror images listed in images.txt
        run: |
          set -eo pipefail
          IFS=$'\n'

          # Helper: trim whitespace
          trim() {
            local var="$*"
            # remove leading/trailing whitespace
            var="${var#"${var%%[![:space:]]*}"}"
            var="${var%"${var##*[![:space:]]}"}"
            printf '%s' "$var"
          }

          # Validate required env
          if [ -z "${ALIYUN_REGISTRY:-}" ] || [ -z "${ALIYUN_NAME_SPACE:-}" ] || [ -z "${ALIYUN_REGISTRY_USER:-}" ] || [ -z "${ALIYUN_REGISTRY_PASSWORD:-}" ]; then
            echo "ERROR: ALIYUN_REGISTRY, ALIYUN_NAME_SPACE, ALIYUN_REGISTRY_USER, ALIYUN_REGISTRY_PASSWORD must be set in secrets."
            exit 1
          fi

          # Optional src creds
          if [ -n "${DOCKERHUB_USER:-}" ] && [ -n "${DOCKERHUB_PASSWORD:-}" ]; then
            SRC_CREDS="--src-creds=${DOCKERHUB_USER}:${DOCKERHUB_PASSWORD}"
            echo "Using Docker Hub credentials for source."
          else
            SRC_CREDS=""
            echo "No Docker Hub credentials provided — will use anonymous pulls (may hit rate limits)."
          fi
          DEST_CREDS="--dest-creds=${ALIYUN_REGISTRY_USER}:${ALIYUN_REGISTRY_PASSWORD}"

          # Read images.txt
          if [ ! -f images.txt ]; then
            echo "ERROR: images.txt not found in repo root. Create it with one image per line."
            exit 1
          fi

          n=0
          while IFS= read -r raw || [ -n "$raw" ]; do
            # strip comments after '#' and trim
            line="${raw%%#*}"
            line=$(trim "$line")
            [ -z "$line" ] && continue

            n=$((n+1))
            echo "---- [$n] Processing: $line ----"

            # Normalize source image:
            # If user supplies 'nginx:1.21' or 'library/nginx:1.21' -> treat as docker.io/library/nginx:1.21
            src="$line"
            # if it contains "://" assume full schema provided
            if [[ "$src" == *"://"* ]]; then
              src_ref="$src"
            else
              # If first path segment looks like a hostname (contains '.' or ':' or 'localhost'), keep it
              firstseg="${src%%/*}"
              if [[ "$firstseg" == *.* || "$firstseg" == *:* || "$firstseg" == "localhost" ]]; then
                # full-qualified, e.g., registry.example.com/foo/bar:tag
                src_ref="docker://$src"
              else
                # not hostname -> assume docker.io. For single name like "nginx:tag" use library prefix if no slash
                if [[ "$src" != */* ]]; then
                  src="library/$src"
                fi
                src_ref="docker://docker.io/$src"
              fi
            fi

            # compute destination path: strip registry if present from src, keep path and tag
            # extract pathAfterRegistry: remove the leading "docker://<registry>/" if exists, else use $src after possible docker.io prefix handled above
            # Re-use $src (which might be prefixed with docker.io/...) to compute path part
            # remove potential schema
            no_schema="${src_ref#docker://}"
            # if it has a registry host (contains '.' or ':' before first '/'), remove it
            firstseg="${no_schema%%/*}"
            if [[ "$firstseg" == *.* || "$firstseg" == *:* || "$firstseg" == "localhost" ]]; then
              path_after_registry="${no_schema#*/}"
            else
              path_after_registry="$no_schema"
            fi

            dest_ref="docker://${ALIYUN_REGISTRY}/${ALIYUN_NAME_SPACE}/${path_after_registry}"

            echo "SRC:  $src_ref"
            echo "DEST: $dest_ref"

            # Retry logic (3 attempts)
            attempt=0
            max_attempts=3
            until [ $attempt -ge $max_attempts ]
            do
              attempt=$((attempt+1))
              echo "Attempt $attempt for $src_ref -> $dest_ref"
              # skopeo copy --all preserves manifest lists and all archs
              if skopeo copy --all ${SRC_CREDS} ${DEST_CREDS} "$src_ref" "$dest_ref"; then
                echo "Successfully copied $src -> ${ALIYUN_REGISTRY}/${ALIYUN_NAME_SPACE}/${path_after_registry}"
                break
              else
                echo "skopeo copy failed on attempt $attempt for $src_ref"
                sleep $((attempt*5))
              fi
            done

            if [ $attempt -ge $max_attempts ]; then
              echo "ERROR: failed to copy $src_ref after $max_attempts attempts"
              # choose whether to exit or continue. We will continue but mark failure.
              echo "Continuing to next image (check logs)."
            fi

            echo "---- done $n ----"
          done < images.txt

          echo "All lines processed."
